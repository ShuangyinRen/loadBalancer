{"name":"Loadbalancer","tagline":"Switch balanceador de carga mediante OpenFlow simulado con ns3","body":"[![C++](https://img.shields.io/badge/C++-14-yellow.svg)](http://www.cplusplus.com/)\r\n[![ns3](https://img.shields.io/badge/ns3-20-orange.svg)](https://www.nsnam.org/ns-3-20/) \r\n[![License](https://img.shields.io/badge/license-CC | By+NC-green.svg)](http://es.creativecommons.org/blog/licencias/) \r\n[![Linkedin](https://img.shields.io/badge/LinkedIn-Carlos-blue.svg)](https://es.linkedin.com/in/carlosrodriguezhernandez)\r\n[![Twitter](https://img.shields.io/badge/Twitter-carrodher-blue.svg)](https://twitter.com/carrodher)\r\n\r\n# Load Balancer\r\nProyecto de la asignatura \"Planificación y Simulación de Redes\" de 4º curso del Grado en Ingeniería de las Tecnologías de Telecomunicación de la Universidad de Sevilla. \r\n\r\n## Contenido\r\n- [Objetivo](#objetivo)\r\n- [Introduccion](#introduccion)\r\n- [Topologia](#topologia)\r\n- [Modos de balanceo](#modos-de-balanceo)\r\n - [Random](#random)\r\n - [Round Robin](#round-robin)\r\n - [IP Random](#ip-random)\r\n- [Instalacion de OpenFlow en ns3-20](#instalacion-de-openflow-en-ns3-20)\r\n- [Archivos y ejecucion](#archivos-y-ejecucion)\r\n - [Ficheros](#ficheros)\r\n - [Uso](#uso)\r\n\r\n## Objetivo\r\nSe pretende desarrollar un Sistema balanceador de carga para servidores haciendo uso del simulador ns3-20, por tanto este proyecto ha sido desarrollado en C++. De esta manera se quieren estudiar diferentes algoritmos de balanceo de carga.\r\n\r\n## Introducción\r\nPara dotar al sistema de un Balanceador de Carga se ha decidido hacer uso del concepto de Redes Definidas por Software (SDN, por sus siglas en inglés); este tipo de redes se basan en la idea de separar el plano físico del plano de control, de esta manera se puede dotar de cierta inteligencia a la red. \r\nEn el plano físico destaca la presencia de equipos \"tradicionales\", principalmente Switches; estos equipos no tienen capacidad para tomar decisiones por sí mismos. Esta capacidad de decisión o inteligencia reside en la figura del Controller, un elemento centralizado desde el cual se puede actuar sobre todos los equipo distribuidos. Una vez introducido el concepto de SDN, hay que mencionar un elemento clave en todo este sistema como es el protocolo OpenFlow. Este protocolo rige el intercambio de mensajes entre los elementos de red y el Controller, para que de esta manera las órdenes y el intercambio de información entre todos los dispositivos se realice de manera adecuada y acorde al estándar.\r\n\r\n## Topología\r\nEn este proyecto se ha diseñado, mediante el simulador ns3-20, una red de equipos clientes que realizan peticiones a un conjunto de servidores. Estas peticiones pasan a través de un switch, el cual es el encargado de balancearlas hacia el servidor adecuado; para realizar esa función de balanceo se han usado diferentes algoritmos implementados en el Controller.\r\n![Mensajes](http://imgur.com/D07cQ91.png)\r\nLa comunicación, mediante OpenFlow, entre el switch y el Controller se realiza cada vez que llega un paquete al switch, básicamente trabaja en dos fases:\r\n- **Primera fase: Información**\r\n  Cuando llega un paquete de datos al switch, éste manda un mensaje OpenFlow al Controller. Este mensaje contiene toda la información relativa al flujo de comunicación que ha llegado al switch, entre otros atributos cabe destacar: IP_src, IP_dst, port_src, port_dst, procolo, MAC_src, MAC_dst, etc\r\n- **Segunda fase: Respuesta**\r\n  Una vez que el Controller tiene información sobre el paquete que ha llegado al siwtch, ejecuta su algoritmo para formar el paquete de respuesta. Tras ejecutar el algoritmo y obtener un resultado satisfactorio, el Controller envía un mensaje OpenFlow de respuesta al switch en el que le dice qué acción debe llevar a cabo con el paquete de datos que ha recibido, principalmente este mensaje OpenFlow contiene dos parámetros: la acción (siempre reenviar) y el puerto del switch por el que reenviar, este puerto es el que va variando en función del algoritmo implementado, de esta manera se produce el balanceo entre los servidores.\r\n\r\n## Modos de balanceo\r\n![Flujo](http://imgur.com/QuE5eiW.png)\r\n#### Random\r\nEn este modo las peticiones se balancean entre los diferentes servidores de manera aleatoria. Cuando llega una petición al switch este determina a qué servidor la envía de manera totalmente aleatoria, para ello se genera un número aleatorio uniforme entre 0 y el número de servidores.\r\nTras un número suficientemente grande de iteracciones la carga debe ser uniforme en todos los servidores, puesto que estadísticamente todos los servidores tienen la misma probabilidad de recibir una petición.\r\n\r\n![R](http://imgur.com/V6AG0V0.png)\r\n#### Round Robin\r\nEn este modo las peticiones se balancean entre los diferentes servidores de mediant el protocolo Round Robin. Cuando llega una petición al switch este determina a qué servidor la envía de manera secuencial, para ello almacena en una lista el último servidor al que envió la petición para en el caso actual mandarla al siguiente, cuando llega al final de la lista vuelve a enviarla al primero.\r\nLa carga debe ser uniforme en todos los servidores sin tener que esperar a que se realice un número grande de simulaciones, puesto que no depende de ningún factor aleatorio, simplemente asigna de manera circular las peticiones.\r\n\r\n![RR](http://imgur.com/XDLHlI9.png)\r\n#### IP Random\r\nEn este modo las peticiones se balancean entre los diferentes servidores en dos fases. Primero teniendo en cuenta la IP origen se determina si ésta es par o impar, en caso de que la IP sea par, la petición será atendida solo por servidores pares. En caso de ser impar se atiende por servidores impares. Una vez determinado esto se genera aleatoriamente el servidor que la atiende, es decir, dentro de los pares o los impares se determina cuál es el que atiende la petición.\r\nTras un número suficientemente grande de iteracciones la carga debe ser uniforme en todos los servidores, puesto que estadísticamente todos los servidores tienen la misma probabilidad de recibir una petición debido a que el tráfico real tendrá el mismo número de IPs pares que impares, y dentro de cada grupo hay la misma probabilidad de elegir un servidor u otro dentro de la lista de servidores pares o impares.\r\n\r\n![IR](http://imgur.com/gtE8xIR.png)\r\n## Instalacion de OpenFlow en ns3-20\r\nDebemos instalar los siguientes paquetes:\r\n\r\n    sudo apt-get install libboost-all-dev\r\n    sudo apt-get install mercurial\r\n\r\nPosteriormente se descarga el código:\r\n\r\n    hg clone http://code.nsnam.org/openflow\r\n    cd openflow\r\n\r\nConfiguramos e instalamos OpenFlow:\r\n\r\n    ./waf configure\r\n    ./waf build\r\n\r\nLinkamos nuestro ns3 con OpenFlow:\r\n\r\n    cd /ruta/hacia/nuestro/ns3/instalado/\r\n    ./waf configure --enable-examples --enable-tests --with-openflow=/ruta/hacia/nuestro/openflow/bajado/antes\r\n\r\nDebemos obtener el atributo OpenFlow marcado como \"enabled\":\r\n\r\n    \"NS-3 OpenFlow Integration     : enabled\"\r\n\r\nPor último, completamos la instalación con:\r\n\r\n    ./waf build\r\n\r\n## Archivos y ejecucion\r\n#### Ficheros\r\n\r\n    controller.h => Librería con las definiciones necesarias en los Controllers\r\n    iprandom_controller.cc  => Controller IP random\r\n    loadbalancer.h => Librería con las definiciones necesarias en el escenario\r\n    Observador.cc => Implementación del observador para obtener datos\r\n    Observador.h  => Librería con las definiciones necesarias en el observador\r\n    random_controller.cc => Controller random\r\n    roundrobin_controller.cc => Controller round-robin\r\n    topologia_ServGraf.cc => Escenario y simulación pintando gráficas en función del tipo de algoritmo introducido\r\n    topologia_TipoGraf.cc => Escenario y simulación pintando gráficas comparando los tres tipos\r\n\r\nNOTA: Para ejecutar se deben incluir estos ficheros en la carpeta ns-3.20/scratch/ en un directorio que se llame con el nombre que se desee ejecutar, por ejemplo, \"loadBalancer\". En este directorio sólo debe aparecer uno de los ficheros topologia_xxxx.cc,según el tipo de simulación que se desee realizar.\r\n\r\n#### Uso\r\n\r\n    NS_LOG=\"Topologia\" ./waf --run \"loadBalancer --number=2 --type=random --dataRate=100Mbps --delay=5us\"\r\n              |                          |            |            |                |           |-> Retraso del canal\r\n              |                          |            |            |                |-> Tasa del canal\r\n              |                          |            |            |-> Tipo de balanceo (random, round-robin ó ip-random)\r\n              |                          |            |-> Número inicial de servidores\r\n              |                          |-> Nombre del directorio en ns-3.20/scratch/\r\n              |-> Activación de las trazas:\r\n                        |-> Topologia para el escenario\r\n                        |-> random para el random Controller\r\n                        |-> roundrobin para el round-robin Controller\r\n                        |-> ip-random para el IP random Controller\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}